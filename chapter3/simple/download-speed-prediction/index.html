<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

<script src='https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest'></script>
<script>
    // Задача: натренировать модель предсказывать время загрузки файлов

    const trainData = {
        sizeMB: [0.080, 9.000, 0.001, 0.100, 8.000,
            5.000, 0.100, 6.000, 0.050, 0.500,
            0.002, 2.000, 0.005, 10.00, 0.010,
            7.000, 6.000, 5.000, 1.000, 1.000],
        timeSec: [0.135, 0.739, 0.067, 0.126, 0.646,
            0.435, 0.069, 0.497, 0.068, 0.116,
            0.070, 0.289, 0.076, 0.744, 0.083,
            0.560, 0.480, 0.399, 0.153, 0.149]
    }

    const testData = {
        sizeMB: [5.000, 0.200, 0.001, 9.000, 0.002,
            0.020, 0.008, 4.000, 0.001, 1.000,
            0.005, 0.080, 0.800, 0.200, 0.050,
            7.000, 0.005, 0.002, 8.000, 0.008],
        timeSec: [0.425, 0.098, 0.052, 0.686, 0.066,
            0.078, 0.070, 0.375, 0.058, 0.136,
            0.052, 0.063, 0.183, 0.087, 0.066,
            0.558, 0.066, 0.068, 0.610, 0.057]
    };

    const trainTensors = {
        sizeMb: tf.tensor2d(trainData.sizeMB, [20, 1]),
        timeSec: tf.tensor2d(trainData.timeSec, [20, 1]),
    };

    const testTensors = {
        sizeMb: tf.tensor2d(testData.sizeMB, [20, 1]),
        timeSec: tf.tensor2d(testData.timeSec, [20, 1]),
    };

    /**
     * В сфере машинного обучения функция отображения входных признаков в целевые называется моделью.
     * Данная модель реализует линейную регрессию (linear regression). Регрессия в контексте машоба
     * означает, что модель возвращает вещественные значения, пытаясь подобрать соответствие для
     * целевых признаков. Этот метод отличен от классификации, при которой выходные сигналы выбираются
     * из некоего набора вариантов.
    */
    const model = tf.sequential();

    /** Основной кирпичик нейронных сетей - слой (layer), модуль обработки данных, который
     * можно считать подстраиваемой функцией, переводящей тензоры в тензоры. В данном случае
     * наша модель состоит из одного плотного слоя с наложенным на форму входного тензора ограничением,
     * описанным с помощью параметра:
     * @param inputShape: [1]
     * Это значит, что слой ожидает входные данные в виде одномерного тензора, хранящего только
     * одно значение. По существу, плотный слой представляет собой настраиваемую функцию
     * умножения­сложения, переводящую каждый входной сигнал в соответствующий выходной.
     * А поскольку на входе и выходе только по одному значению, эта модель представляет собой
     * простое линейное уравнение y = m * x + b. В плотном слое m называется ядром (kernel),
     * а b — смещением (bias).
     *
     * В данном случае мы сформировали линейную модель для отношения между входным ( sizeMB )
     * и выходным ( timeSec ) сигналами:
     * timeSec = ядро * sizeMB + смещение
     *
     * В этом уравнении четыре члена. Два из них с точки зрения обучения модели
     * фиксированы: значения sizeMB и timeSec определяются обучающими данными
     * (trainData). Оставшиеся два члена, ядро и смещение, представляют собой параметры модели.
     * Их значения выбираются случайным образом при создании модели.
     * Полученное на основе этих случайных значений предсказание продолжительности скачивания,
     * конечно, хорошим не будет. Чтобы получить адекватные предсказания,
     * необходимо найти хорошие значения ядра и смещения путем обучения модели на данных.
     * Этот поиск и представляет собой процесс обучения. Для поиска хороших значений ядра и смещения
     * (которые совокупно называются весами или весовыми коэффициентами) необходимы две вещи:
     *
     *  1) мера того, насколько хороши конкретные значения весов;
     *
     *  2) способ обновления значений весов, чтобы на следующем шаге модель была лучше,
     *  чем на предыдущем, относительно упомянутой выше меры.
     */
    model.add(tf.layers.dense({inputShape: [1], units: 1}));

    /**
     * Для подготовки сети к обучению необходимо выбрать меру и метод обновления, соответствующие
     * двум нужным для модели элементам, перечисленным выше. Это делается на шаге, в терминологии
     * TensorFlow.js, компиляции модели (model compilation), для которого нужны:
     *
     *  1) функция потерь (loss function) — метрика погрешности. Именно на ее основе сеть
     *  измеряет качество работы на обучающих данных и определяет, в каком направлении двигаться дальше.
     *  При обучении требуется возможность построения графика функции потерь относительно времени.
     *  Эта функция должна стремиться к нулю.
     *
     *  2) оптимизатор (optimizer) — алгоритм обновления сетью своих весов (в данном
     *  случае ядра и смещения) на основе данных и функции потерь.
     *
     *  Мы вызываем для модели метод compile , указывая в качестве оптимизатора'sgd',
     *  а в качестве функции потерь — 'meanAbsoluteError' . 'meanAbsoluteError' означает,
     *  что наша функция потерь вычисляет абсолютное (положительное) значение удаленности
     *  предсказаний от целевых значений, после чего возвращает среднее значение полученного.
     *
     *  sgd означает стохастический градиентный спуск (stochastic gradient descent).
     *  Если вкратце, это значит, что для выбора корректировок весов, необходимых для снижения потерь,
     *  мы воспользуемся математическим анализом. После чего выполним эти корректировки
     *  и повторим процесс.
     */
    model.compile({optimizer: 'sgd', loss: 'meanAbsoluteError'});

    (async function() {
        /**
         * Обучение модели в TensorFlow.js запускается вызовом ее метода fit() . Происходит подгонка
         * (fit) модели под обучающие данные. В данном случае мы передаем тензор sizeMB в качестве
         * входного сигнала и тензор timeSec в качестве желаемого выходного. Мы также передаем объект с настройками
         * конфигурации, содержащий поле epochs , означающее, что мы хотели бы пройти по обучающим данным
         * ровно десять раз. В глубоком обучении отдельный проход по полному обучающему набору данных
         * называется эпохой (epoch).
         */
        await model.fit(trainTensors.sizeMb, trainTensors.timeSec, {epochs: 200});

        /**
         * По завершении подгонки модели хочется проверить, как она работает. Главное,
         * проверять модель необходимо на данных, которые не использовались во время обучения.
         * Метод evaluate() модели вычисляет функцию потерь для переданных ему признаков и
         * целевых значений примера данных. Он напоминает метод fit() тем, что вычисляет ту же функцию
         * потерь, но отличается тем, что не обновляет веса модели. Мы используем evaluate() для оценки
         * работы модели на контрольных данных, то есть чтобы понять, насколько хорошо она будет работать
         * в дальнейшем. Я получил числа в диапазоне от 0.01 до 0.06, поперезагружав страницу.
         * Хорошо ли это? Лучше ли, чем константная оценка? Одна неплохая возможная константа для этого —
         * средняя задержка.
         */
        console.log('Средняя погрешность на тестовых данных: ');
        model.evaluate(testTensors.sizeMb, testTensors.timeSec).print();

        /**
         * Теперь, имея обученную модель, можно использовать ее для предсказания длительности скачивания
         * файлов. Делается это при помощи метода predict:
         */
        const smallFile = 1;
        const bigFile = 100;
        const hugeFile = 10000;

        const filesTensor = tf.tensor2d([[smallFile], [bigFile], [hugeFile]]);
        console.log('Рассчетное время скачивания файлов объемом 1, 100, 10 000 Мбайт: ');
        model.predict(filesTensor).print();
    })();

    // среднее время скачивания для обучающего набора данных:
    const avgDelaySec = tf.mean(trainData.timeSec);
    // 0.2950499951839447
    console.log('Среднее время скачивания: ')
    avgDelaySec.print();
</script>
</body>
</html>